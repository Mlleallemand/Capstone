# Online offer response analysis

This repository contains an analysis using parametric statistics (ANOVA, ttests) as well as a Random Forest Classifier in order to assess which offers to send to which customer groups.

The data set contains simulated data that mimics customer behavior on the Starbucks rewards mobile app. Once every few days, Starbucks sends out an offer to users of the mobile app. An offer can be merely an advertisement for a drink or an actual offer such as a discount or BOGO (buy one get one free). Some users might not receive any offer during certain weeks.

The task was to combine transaction, demographic and offer data to determine which demographic groups respond best to which offer type. 


## Necessary Python libraries

#### contained in standard library
* [datetime]

#### not contained in standard library
* [Numpy] version 1.18.5 
* [Pandas] version 1.0.5
* [Seaborn] version 0.11.1
* [json] version 2.0.9
* [matplotlib]
* [sklearn]
* [pingouin] version 0.3.9
* [statsmodels] version 0.11.1
* [sklearn]

## Repository contents

| Folder | Filename | Description|
| -------- | -------- | -----------|
| main | Starbucks_Capstone_notebook.ipynb | Notebook containing all analysis scripts |
| main | tree.dot |file generated by RandomForest tree visualization |
| data | portfolio.json | Data containing the offering portfolio |
| data | profile.json | Data containing subject information |
| data | transcript.json | Data containing subject transactions and offer events (received, completed,..) |
| Figures/ANOVA | Folder for pairwise comparison plots |  |
| Figures/RF | Folder for RandomForestClassifier tree visualizations |  |
| Figures/Welch | Folder for results on Welch ANOVA | |

### Instructions:
1. Make sure to generate the /Figures and /data in the main directory 

2. Add the Starbucks data (portfolio.json, profil.json, transcript.json) in the data/ folder - 
   I did not add the datafiles as I wasn't sure about licensing

3. Open the Jupyter notebook and run all cells containing function definitions (end of notebook)

4. Run the notebook

### Summary:

I used two separate approaches:

- using a General Linear Model (ANOVA and post-hoc tests) which resulted in significant main effects of offer response on both income and membership duration

- training a random forest classifer to predict offer response using income and membership duration as predictors. Adding gender or age did not improve the model much, in case of age this was probably due to the correlation of age with income present in the dataset

I trained a RF classifier for each of the eight offer types using "success", and "ignore" as class labels and "income" and "membership duration in days" as predictors. Prediction accuracy was 0.77 on average across all offer types, which unfortunately also did not improve by taking into account more class labels or weighted responses.

Looking at the different offer types, a mixture of income and membership threshold can be used to find the target groups.

### Outlook:

There are some easy paths to implement. We can for example exclude customers who have a very high ratio of ignored offers (say > the 95 percentile of the distribution) from further offers, as they might perceive continued offers as SPAM. In our dataset, this affects 353 customers.

For the offer structure, the individual trees need to be looked at to determine the optimal split by 
income or membership for targeting the customer group.

What I did not consider in this analysis was repeated-measures or time effects. Looking at data records in terms of a time-series, one could extract regularities (e.g. somebody always buys coffee on Mondays to Fridays) and only send offers rarely - as these customers need less incentive than others.

Another factor to consider is the "training" effect: if customers failed to complete difficult offers, they might turn to ignorant customers. So one option would be to send easier ones (with longer duration or less purchase required). All of this requires analysing sequences of offers which I did not do due to time constraints.

### Note:


[Numpy]:<https://numpy.org>
[Scipy]:<https://scipy.org>
[Pandas]:<https://pandas.pydata.org/>
[Seaborn]:<https://seaborn.pydata.org/>
[scikit learn]:<https://scikit-learn.org/stable/>
[matplotlib]:<https://matplotlib.org/>
[sqlite3]:<https://www.sqlite.org/index.html>
[sqlalchemy]:<https://www.sqlalchemy.org/>
[sklearn]:<https://scikit-learn.org/stable/>
[joblib]:<https://joblib.readthedocs.io/en/latest/>
[pickle]:<https://docs.python.org/3/library/pickle.html>
[nltk]:<https://www.nltk.org/>
[pywsd]:<https://pypi.org/project/pywsd/>
[flask]:<https://flask.palletsprojects.com/en/1.1.x/>
[pingouin]:<https://pingouin-stats.org/>
[errno]:<>
[os]:<>
[sys]:<>
[re]:<>
[datetime]:<https://docs.python.org/3/library/datetime.html>